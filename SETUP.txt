SlotSwapper - Peer-to-Peer Time Slot Scheduler
==============================================

PROJECT OVERVIEW
----------------
SlotSwapper is a full-stack application that allows users to exchange time slots with each other.
Users can mark their calendar events as "swappable" and request to swap slots with other users.
The application features real-time notifications via WebSockets.

TECHNOLOGY STACK
----------------
Backend:
- Node.js + Express + TypeScript
- PostgreSQL database
- JWT authentication
- Socket.io for real-time notifications
- Jest for testing

Frontend:
- React + TypeScript
- Vite build tool
- React Router for navigation
- Axios for API calls
- Socket.io-client for WebSockets
- React Toastify for notifications

DevOps:
- Docker & Docker Compose
- Nginx for frontend serving
- Ready for deployment on Render/Heroku (backend) and Vercel (frontend)

FEATURES IMPLEMENTED
--------------------
✅ User Authentication (Sign Up / Log In with JWT)
✅ Calendar Management (CRUD operations for events)
✅ Swap Logic (Request, Accept, Reject swaps)
✅ Real-time WebSocket Notifications
✅ Beautiful, Modern UI with Gradient Design
✅ Responsive Layout
✅ Unit & Integration Tests
✅ Docker Containerization
✅ Deployment Configurations

LOCAL SETUP INSTRUCTIONS
-------------------------

Option 1: Using Docker (Recommended)
-------------------------------------
1. Make sure Docker and Docker Compose are installed on your system

2. Clone the repository and navigate to the project directory

3. Start all services with Docker Compose:
   $ docker-compose up --build

4. The application will be available at:
   - Frontend: http://localhost:3000
   - Backend: http://localhost:3001
   - Database: PostgreSQL on port 5432

5. To stop the services:
   $ docker-compose down

Option 2: Manual Setup
----------------------
Prerequisites:
- Node.js (v18 or higher)
- PostgreSQL (v15 or higher)
- npm or yarn

Backend Setup:
1. Navigate to the backend directory:
   $ cd backend

2. Install dependencies:
   $ npm install

3. Create a PostgreSQL database named 'slotswapper'

4. Copy .env.example to .env and update DATABASE_URL if needed:
   $ cp .env.example .env

5. Run database migrations:
   $ npm run migrate

6. Start the development server:
   $ npm run dev

   Backend will run on http://localhost:3001

Frontend Setup:
1. Open a new terminal and navigate to the frontend directory:
   $ cd frontend

2. Install dependencies:
   $ npm install

3. Copy .env.example to .env (defaults should work for local development):
   $ cp .env.example .env

4. Start the development server:
   $ npm run dev

   Frontend will run on http://localhost:3000

RUNNING TESTS
-------------
Backend Tests:
$ cd backend
$ npm test

To run tests with coverage:
$ npm test -- --coverage

To run tests in watch mode:
$ npm run test:watch

API ENDPOINTS
-------------

Authentication:
POST   /api/auth/signup
       Body: { name, email, password }
       Returns: { token, user: { id, name, email } }

POST   /api/auth/login
       Body: { email, password }
       Returns: { token, user: { id, name, email } }

Events:
GET    /api/events
       Headers: Authorization: Bearer <token>
       Returns: Array of user's events

POST   /api/events
       Headers: Authorization: Bearer <token>
       Body: { title, start_time, end_time, status? }
       Returns: Created event

GET    /api/events/:id
       Headers: Authorization: Bearer <token>
       Returns: Event details

PUT    /api/events/:id
       Headers: Authorization: Bearer <token>
       Body: { title?, start_time?, end_time?, status? }
       Returns: Updated event

DELETE /api/events/:id
       Headers: Authorization: Bearer <token>
       Returns: 204 No Content

Swap Operations:
GET    /api/swappable-slots
       Headers: Authorization: Bearer <token>
       Returns: Array of swappable slots from other users

POST   /api/swap-request
       Headers: Authorization: Bearer <token>
       Body: { mySlotId, theirSlotId }
       Returns: Created swap request

POST   /api/swap-response/:requestId
       Headers: Authorization: Bearer <token>
       Body: { accepted: boolean }
       Returns: Updated swap request

GET    /api/requests/incoming
       Headers: Authorization: Bearer <token>
       Returns: Array of incoming swap requests

GET    /api/requests/outgoing
       Headers: Authorization: Bearer <token>
       Returns: Array of outgoing swap requests

WEBSOCKET EVENTS
----------------
Client -> Server:
- Connection requires JWT token in auth.token

Server -> Client:
- swap_request_received: Emitted when user receives a new swap request
- swap_request_accepted: Emitted when a swap request is accepted
- swap_request_rejected: Emitted when a swap request is rejected

DATABASE SCHEMA
---------------
Tables:
1. users
   - id (serial primary key)
   - name (varchar)
   - email (varchar, unique)
   - password_hash (varchar)
   - created_at, updated_at (timestamps)

2. events
   - id (serial primary key)
   - user_id (foreign key -> users)
   - title (varchar)
   - start_time (timestamp)
   - end_time (timestamp)
   - status (enum: BUSY, SWAPPABLE, SWAP_PENDING)
   - created_at, updated_at (timestamps)

3. swap_requests
   - id (serial primary key)
   - requester_id (foreign key -> users)
   - requester_slot_id (foreign key -> events)
   - target_user_id (foreign key -> users)
   - target_slot_id (foreign key -> events)
   - status (enum: PENDING, ACCEPTED, REJECTED)
   - created_at, updated_at (timestamps)

DEPLOYMENT
----------

Backend (Render/Heroku):
1. Render: Use the provided render.yaml file
   - Push to GitHub
   - Connect repository to Render
   - Render will auto-deploy using render.yaml

2. Heroku:
   - Install Heroku CLI
   - $ heroku create slotswapper-api
   - $ heroku addons:create heroku-postgresql:hobby-dev
   - $ git push heroku main
   - Set environment variables in Heroku dashboard

Frontend (Vercel/Netlify):
1. Vercel:
   - Push to GitHub
   - Import project to Vercel
   - Set environment variables:
     - VITE_API_URL: Your backend URL
     - VITE_WS_URL: Your backend URL
   - Deploy

2. Netlify:
   - Push to GitHub
   - Import project to Netlify
   - Build command: npm run build
   - Publish directory: dist
   - Set environment variables

DESIGN CHOICES & ARCHITECTURE
------------------------------
1. JWT Authentication: Stateless authentication allowing easy scaling
2. PostgreSQL: Robust relational database with strong ACID guarantees
3. Socket.io: Real-time bidirectional communication for instant notifications
4. TypeScript: Type safety across the stack
5. Transaction Safety: Swap operations use database transactions to ensure data integrity
6. Status Management: Events have status (BUSY/SWAPPABLE/SWAP_PENDING) to prevent race conditions
7. Beautiful UI: Modern gradient design with smooth transitions and responsive layout

CHALLENGES FACED
----------------
1. Race Conditions: Solved by implementing status checks and database transactions
2. Real-time Updates: Implemented WebSocket connection with automatic reconnection
3. Complex Swap Logic: Required careful transaction management to ensure both events swap owners atomically
4. State Synchronization: Used custom events to update UI across components when swaps occur

PROJECT STRUCTURE
-----------------
/
├── backend/
│   ├── src/
│   │   ├── __tests__/       # Unit & integration tests
│   │   ├── config/          # Database configuration
│   │   ├── middleware/      # Auth, validation, error handling
│   │   ├── migrations/      # Database migrations
│   │   ├── models/          # Data models
│   │   ├── routes/          # API routes
│   │   ├── utils/           # Utilities (JWT)
│   │   ├── socket.ts        # WebSocket setup
│   │   └── server.ts        # Express server
│   ├── Dockerfile
│   ├── package.json
│   └── tsconfig.json
│
├── frontend/
│   ├── src/
│   │   ├── components/      # Reusable components
│   │   ├── contexts/        # React contexts (Auth, Socket)
│   │   ├── pages/           # Page components
│   │   ├── App.tsx          # Main app component
│   │   ├── main.tsx         # Entry point
│   │   └── index.css        # Global styles
│   ├── Dockerfile
│   ├── nginx.conf           # Nginx configuration
│   ├── package.json
│   └── vite.config.ts
│
└── docker-compose.yml       # Docker Compose configuration

TESTING
-------
The backend includes comprehensive tests covering:
- Authentication (signup, login, validation)
- Events CRUD operations
- Swap logic (request creation, acceptance, rejection)
- Authorization checks
- Edge cases and error handling

Coverage includes all critical paths with >70% code coverage.

SECURITY CONSIDERATIONS
-----------------------
- Passwords hashed with bcrypt
- JWT tokens for stateless authentication
- CORS configured
- SQL injection prevention via parameterized queries
- Input validation on all endpoints
- Authorization checks on all protected routes

CONTACT & SUPPORT
-----------------
For questions or issues, please refer to the repository's issue tracker.
